package bob.com.player;

import java.awt.geom.Point2D;
import java.util.HashMap;
import java.util.Map;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;

import bob.com.level.World;
import bob.com.player.Player.State;
import bob.com.runner.Runner;
import bob.com.screens.GameOverScreen;
import bob.com.tiles.Tile;

public class Controller {

	enum Keys {
		LEFT, RIGHT, JUMP, FIRE
	}

	private World 	world;
	private Player 	player;
	private float jumptime;
	private float deathTime;
	static Map<Keys, Boolean> keys = new HashMap<Controller.Keys, Boolean>();
	private  float jumpTime 	= 0f;
	private static float accel 	= 0;
	private  float grav = -0.5f;
	private static final float MAX_JUMP_SPEED	= 1f;
	private static final float DAMP 			= 0.90f;
	private static final float MAX_VEL 			= 2f;
	
	// these are temporary
	private static final float WIDTH = 10f;
	private long	jumpPressedTime;
	private boolean jumpingPressed;
	private boolean grounded = false;
	private Runner game;	
	static {
		keys.put(Keys.LEFT, false);
		keys.put(Keys.RIGHT, false);
		keys.put(Keys.JUMP, false);
		keys.put(Keys.FIRE, false);
	};

	public Controller(World world,Runner game) {
		this.world = world;
		this.game = game;
		this.player = world.getPlayer();
	}

	// ** Key presses and touches **************** //

	public void leftPressed() {
		keys.get(keys.put(Keys.LEFT, true));
	}

	public void rightPressed() {
		keys.get(keys.put(Keys.RIGHT, true));
	}

	public void jumpPressed() {
		keys.get(keys.put(Keys.JUMP, true));
	}

	public void firePressed() {
		keys.get(keys.put(Keys.FIRE, false));
	}

	public void leftReleased() {
		keys.get(keys.put(Keys.LEFT, false));
	}

	public void rightReleased() {
		keys.get(keys.put(Keys.RIGHT, false));
	}

	public void jumpReleased() {
		keys.get(keys.put(Keys.JUMP, false));
	}

	public void fireReleased() {
		keys.get(keys.put(Keys.FIRE, false));
	}

	/** The main update method **/
	public void update(float delta) {
		processInput();
		player.update(delta);
		player.getVelocity().x += 1f;
		if(UpCollision()){
			player.getVelocity().y  = 0;
		}
		else
		{
			player.getVelocity().y += grav;
		}
		if(player.getVelocity().x > MAX_VEL){
			player.getVelocity().x = MAX_VEL;
		}
		if(player.getVelocity().y < -6){
			player.getVelocity().y = -6;
		}
		if(this.player.getState() == State.JUMPING){
			
		}
		if(RightCollision()){
			player.setState(State.DYING);
		}
		if(player.getState() == State.DYING){
			player.setTexture(new Texture("images/deadPlayer.png"));
			player.getVelocity().x = 0;
			if(deathTime > 0 && deathTime < 1){
			player.getVelocity().y = 3;
			}
			else
			{player.getVelocity().y = -3;
			
			}
			
			deathTime += delta;
			if(deathTime > 3){
				this.game.setScreen(new GameOverScreen(game));
				deathTime  = 0;
			}
		}
		Gdx.app.log("speed :",Float.toString(player.getVelocity().y) + ": "+player.getState().toString());
	}

	private void processInput() {
		if (keys.get(Keys.JUMP) && UpCollision() && player.getState() != State.DYING
				) {
			player.getVelocity().y = player.getJump_velocity();
			
		}
	}

	private  boolean UpCollision(){
		for(Tile tile:world.getTiles()){
			Rectangle rect = new Rectangle(tile.getPosition().x,tile.getPosition().y,tile.get_top().width,tile.get_top().height);
			if(player.getBounds().overlaps(rect)){	
				if(player.getPosition().y-32 < rect.y){

					return true;
				}
			}

		 }

		return false;

	}
	private  boolean RightCollision(){
		for(Tile tile:world.getTiles()){
			Rectangle rect = new Rectangle(tile.get_rightSide().x,tile.get_rightSide().y,tile.get_rightSide().width,tile.get_rightSide().height);
			if(player.getBounds().overlaps(rect) && player.getState() != State.DYING
					){	
				if(player.getPosition().x < rect.x){

					return true;
				}
			}

		 }

		return false;

	}
	
}
						
